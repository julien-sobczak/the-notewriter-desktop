import path from 'path'
import fs from 'fs'
import { execFile } from 'child_process'
import { promisify } from 'util'

import {
  EditorStaticConfig,
  EditorDynamicConfig,
  RepositoryRefConfig,
  RepositoryConfig,
  DeckRef,
  DeckConfig,
  StatConfig,
  StatConfigWithContext,
  JournalConfig,
  JournalConfigWithContext,
  Desk,
  DeskWithContext,
  QueryConfig,
  QueryConfigWithContext,
  RepositoryQuery
} from './Model'
import { normalizePath } from './util'

const execFileAsync = promisify(execFile)

export default class ConfigManager {
  // Static (~/.nt/editorconfig.jsonnet), Dynamic (~/.nt/editorconfig.json) or Collection (.nt/config)?
  //
  // * Static configuration refers to configuration specific to The NoteWriter Desktop application
  //   Ex: journaling templates, etc.
  // * Dynamic configuration is also specific to The NoteWriter Desktop application but is not expected
  //   to be edited manually. This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorStaticConfig!: EditorStaticConfig

  editorDynamicConfig!: EditorDynamicConfig

  repositoryConfigs: { [key: string]: RepositoryConfig } = {}

  // Configuration directory path where editorconfig.jsonnet and editorconfig.json are stored
  configDir!: string

  constructor() {
    // Public constructor
  }

  // Create ConfigManager for single repository mode
  // repositoryPath: absolute path to the repository directory
  static async createFromRepository(repositoryPath: string): Promise<ConfigManager> {
    const configDir = path.join(repositoryPath, '.nt')
    const configPath = path.join(configDir, 'editorconfig.jsonnet')

    const instance = new ConfigManager()
    instance.configDir = configDir

    let staticConfig: EditorStaticConfig
    if (fs.existsSync(configPath)) {
      console.log(`Reading configuration from ${configPath}`)
      staticConfig = await instance.#evaluateJsonnetConfig(configPath)
    } else {
      console.log(`No editorconfig.jsonnet found in repository, generating in-memory config`)
      staticConfig = ConfigManager.#generateDefaultRepositoryConfig(repositoryPath)
    }

    const dynamicConfig = await instance.#readDynamicConfig()

    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  // Create ConfigManager for multi repository mode
  // configPath: absolute path to the directory containing editorconfig.jsonnet (typically $NT_HOME)
  static async create(configPath: string): Promise<ConfigManager> {
    const configFile = path.join(configPath, 'editorconfig.jsonnet')

    if (!fs.existsSync(configFile)) {
      throw new Error(`No configuration file found. Expected: ${configFile}`)
    }

    console.log(`Reading configuration from ${configFile}`)

    const instance = new ConfigManager()
    instance.configDir = configPath

    const staticConfig = await instance.#evaluateJsonnetConfig(configFile)
    const dynamicConfig = await instance.#readDynamicConfig()

    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  // Evaluate a Jsonnet configuration file
  async #evaluateJsonnetConfig(configPath: string): Promise<EditorStaticConfig> {
    // Several solutions exist to evaluate Jsonnet files in Node.js:
    // * Use a WebAssembly to run the Jsonnet VM in the browser (no popular library found)
    // * Use a native Node.js addon (ex: https://github.com/hanazuki/node-jsonnet but many issues after every upgrade of cmake)
    // * Use the jsonnet binary directly (requires users to install jsonnet separately)
    // For simplicity, we use the latest solution for now.

    try {
      // Execute jsonnet binary from PATH
      const { stdout } = await execFileAsync('jsonnet', [configPath])
      const config = JSON.parse(stdout) as EditorStaticConfig
      return ConfigManager.#applyDefaultStaticConfig(config)
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(
          'jsonnet binary not found in PATH. Please install jsonnet: https://github.com/google/go-jsonnet'
        )
      }
      throw new Error(`Failed to evaluate Jsonnet file: ${error.message}`)
    }
  }

  // Generate a default configuration for a single repository
  static #generateDefaultRepositoryConfig(repositoryPath: string): EditorStaticConfig {
    const config: EditorStaticConfig = {
      repositories: [
        {
          name: 'Default',
          slug: 'default',
          path: repositoryPath,
          selected: true
        }
      ]
    }
    return ConfigManager.#applyDefaultStaticConfig(config)
  }

  async #readDynamicConfig(): Promise<EditorDynamicConfig> {
    const dynamicConfigPath = path.join(this.configDir, 'editorconfig.json')
    if (!fs.existsSync(dynamicConfigPath)) {
      // Define default configuration
      return {
        desks: [],
        favorites: [],
        bookmarks: [],
        tags: []
      } as EditorDynamicConfig
    }

    const data = fs.readFileSync(dynamicConfigPath, 'utf8')
    console.log(`Reading dynamic configuration from ${dynamicConfigPath}...`)
    const config = JSON.parse(data) as EditorDynamicConfig
    console.log(data, config)
    return config
  }

  async #readRepositoryConfig(repositoryRef: RepositoryRefConfig): Promise<RepositoryConfig> {
    const repositoryPath = normalizePath(repositoryRef.path)
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json')
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`)
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8')
    const config = JSON.parse(data) as RepositoryConfig
    return config
  }

  // Traverse the static configuration to apply default values.
  static #applyDefaultStaticConfig(config: EditorStaticConfig): EditorStaticConfig {
    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i]
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true
        }
      }
    }

    return config
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories.filter((repository) => repository.selected)
  }

  save(config: EditorDynamicConfig) {
    const configPath = path.join(this.configDir, 'editorconfig.json')
    console.log(`Saving ${configPath}...`)
    const content = JSON.stringify(config)
    console.log(content)
    fs.writeFile(configPath, content, (err) => {
      if (err) {
        console.error(err)
      }
    })
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug)
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects')
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`)
    }
    return objectsPath
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorStaticConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`)
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug]
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`)
    }
    return repositoryConfig
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(deckRef.repositorySlug)
    if (!repositoryConfig.decks) {
      throw new Error(`No decks found for repository ${deckRef.repositorySlug}`)
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck
      }
    }
    throw new Error(`No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`)
  }

  // Returns all stats from selected repositories
  selectedStats(): StatConfigWithContext[] {
    const stats: StatConfigWithContext[] = []
    const selectedRepos = this.selectedRepositories()

    for (const repo of selectedRepos) {
      const repoConfig = this.repositoryConfigs[repo.slug]
      if (repoConfig?.stats) {
        stats.push(...repoConfig.stats.map((stat) => ({ ...stat, repositorySlug: repo.slug })))
      }
    }

    return stats
  }

  // Returns all journals from selected repositories
  selectedJournals(): JournalConfigWithContext[] {
    const journals: JournalConfigWithContext[] = []
    const selectedRepos = this.selectedRepositories()

    for (const repo of selectedRepos) {
      const repoConfig = this.repositoryConfigs[repo.slug]
      if (repoConfig?.journals) {
        journals.push(
          ...repoConfig.journals.map((journal) => ({ ...journal, repositorySlug: repo.slug }))
        )
      }
    }

    return journals
  }

  // Returns all desks from selected repositories
  selectedDesks(): DeskWithContext[] {
    const desks: DeskWithContext[] = []
    const selectedRepos = this.selectedRepositories()

    for (const repo of selectedRepos) {
      const repoConfig = this.repositoryConfigs[repo.slug]
      if (repoConfig?.desks) {
        desks.push(...repoConfig.desks.map((desk) => ({ ...desk, repositorySlug: repo.slug })))
      }
    }

    return desks
  }

  // Returns all queries matching a specific tag from selected repositories
  selectedQueriesMatchingTag(tag: string): QueryConfigWithContext[] {
    const queries: QueryConfigWithContext[] = []
    const selectedRepos = this.selectedRepositories()

    for (const repo of selectedRepos) {
      const repoConfig = this.repositoryConfigs[repo.slug]
      if (repoConfig?.queries) {
        for (const [, queryConfig] of Object.entries(repoConfig.queries)) {
          if (queryConfig.tags && queryConfig.tags.includes(tag)) {
            queries.push({ ...queryConfig, repositorySlug: repo.slug })
          }
        }
      }
    }

    return queries
  }

  // Returns all queries with 'inspiration' tag from selected repositories
  selectedInspirations(): QueryConfigWithContext[] {
    return this.selectedQueriesMatchingTag('inspiration')
  }
}

import path from 'path'
import fs from 'fs'

import {
  EditorConfig,
  RepositoryRefConfig,
  RepositoryConfig,
  DeckRef,
  DeckConfig
} from './Model'
import { normalizePath } from './util'

export default class ConfigManager {
  // Editor config (editorconfig.json) or Collection (.nt/config)?
  //
  // * Editor configuration is specific to The NoteWriter Desktop application
  //   and contains the list of repositories, bookmarks, desks, and tabs.
  //   This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorConfig!: EditorConfig

  repositoryConfigs: { [key: string]: RepositoryConfig } = {}

  // Configuration directory path where editorconfig.json is stored
  configDir!: string

  constructor() {
    // Public constructor
  }

  // Create ConfigManager for single repository mode
  // repositoryPath: absolute path to the repository directory
  static async createFromRepository(repositoryPath: string): Promise<ConfigManager> {
    const configDir = path.join(repositoryPath, '.nt')
    const configPath = path.join(configDir, 'editorconfig.json')

    const instance = new ConfigManager()
    instance.configDir = configDir

    let editorConfig: EditorConfig
    if (fs.existsSync(configPath)) {
      console.log(`Reading configuration from ${configPath}`)
      editorConfig = await instance.#readEditorConfig()
    } else {
      console.log(`No editorconfig.json found in repository, creating empty config`)
      editorConfig = {
        repositories: [],
        desks: [],
        bookmarks: [],
        tabs: []
      }
    }

    // Ensure the current repository is in the repositories list
    const currentRepo: RepositoryRefConfig = {
      name: 'Default',
      slug: 'default',
      path: repositoryPath,
      selected: true
    }
    
    const existingRepoIndex = editorConfig.repositories.findIndex(
      (r) => r.path === repositoryPath
    )
    if (existingRepoIndex >= 0) {
      // Update existing repository
      editorConfig.repositories[existingRepoIndex] = {
        ...editorConfig.repositories[existingRepoIndex],
        path: repositoryPath,
        selected: true
      }
    } else {
      // Add new repository
      editorConfig.repositories.push(currentRepo)
    }

    // Apply default values
    editorConfig = ConfigManager.#applyDefaultEditorConfig(editorConfig)

    instance.editorConfig = editorConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  // Create ConfigManager for multi repository mode
  // configPath: absolute path to the directory containing editorconfig.json (typically $NT_HOME)
  static async create(configPath: string): Promise<ConfigManager> {
    const configFile = path.join(configPath, 'editorconfig.json')

    const instance = new ConfigManager()
    instance.configDir = configPath

    let editorConfig: EditorConfig
    if (fs.existsSync(configFile)) {
      console.log(`Reading configuration from ${configFile}`)
      editorConfig = await instance.#readEditorConfig()
    } else {
      console.log(`No editorconfig.json found, creating empty config`)
      editorConfig = {
        repositories: [],
        desks: [],
        bookmarks: [],
        tabs: []
      }
    }

    // Apply default values
    editorConfig = ConfigManager.#applyDefaultEditorConfig(editorConfig)

    instance.editorConfig = editorConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  async #readEditorConfig(): Promise<EditorConfig> {
    const editorConfigPath = path.join(this.configDir, 'editorconfig.json')
    if (!fs.existsSync(editorConfigPath)) {
      // Define default configuration
      return {
        repositories: [],
        desks: [],
        bookmarks: [],
        tabs: []
      } as EditorConfig
    }

    const data = fs.readFileSync(editorConfigPath, 'utf8')
    console.log(`Reading editor configuration from ${editorConfigPath}...`)
    const config = JSON.parse(data) as EditorConfig
    console.log(data, config)
    return config
  }

  async #readRepositoryConfig(repositoryRef: RepositoryRefConfig): Promise<RepositoryConfig> {
    const repositoryPath = normalizePath(repositoryRef.path)
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json')
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`)
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8')
    const config = JSON.parse(data) as RepositoryConfig
    return config
  }

  // Traverse the editor configuration to apply default values.
  static #applyDefaultEditorConfig(config: EditorConfig): EditorConfig {
    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i]
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true
        }
      }
    }

    return config
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorConfig.repositories
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorConfig.repositories.filter((repository) => repository.selected)
  }

  save(config: EditorConfig) {
    const configPath = path.join(this.configDir, 'editorconfig.json')
    console.log(`Saving ${configPath}...`)
    const content = JSON.stringify(config)
    console.log(content)
    fs.writeFile(configPath, content, (err) => {
      if (err) {
        console.error(err)
      }
    })
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug)
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects')
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`)
    }
    return objectsPath
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`)
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug]
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`)
    }
    return repositoryConfig
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(deckRef.repositorySlug)
    if (!repositoryConfig.decks) {
      throw new Error(`No decks found for repository ${deckRef.repositorySlug}`)
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck
      }
    }
    throw new Error(`No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`)
  }
}

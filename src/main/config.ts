import path from 'path'
import os from 'os'
import fs from 'fs'
import { execFile } from 'child_process'
import { promisify } from 'util'

import {
  EditorStaticConfig,
  EditorDynamicConfig,
  RepositoryRefConfig,
  DailyQuoteConfig,
  RepositoryConfig,
  DeckRef,
  DeckConfig
} from './Model'
import { normalizePath } from './util'

const execFileAsync = promisify(execFile)

// Module-level state to store the active config directory path.
// This is initialized once during ConfigManager.create() and determines where
// configuration files are read from and saved to. It enables the homeDir()
// function to return the correct path based on the launch context without
// requiring all callers to pass the ConfigManager instance.
let activeConfigDirectory: string | null = null

// Returns the configuration directory based on launch context.
// This function's behavior is determined by activeConfigDirectory which is set
// during ConfigManager.create() based on how the application was launched:
// - If launched from within a repository or with a directory argument: <repo>/.nt
// - Otherwise: $NT_HOME or ~/.nt (standard mode)
export function homeDir() {
  if (activeConfigDirectory) {
    return activeConfigDirectory
  }
  console.log(`NT_HOME is set to ${process.env.NT_HOME}`)
  if (process.env.NT_HOME) {
    return process.env.NT_HOME
  }
  return path.join(os.homedir(), '.nt')
}

// Detect if a directory is a NoteWriter repository
function isRepository(dirPath: string): boolean {
  const ntDir = path.join(dirPath, '.nt')
  return fs.existsSync(ntDir) && fs.statSync(ntDir).isDirectory()
}

// Determine the launch context and return the appropriate config directory
function determineLaunchContext(): { configDir: string; repositoryPath: string | null } {
  // Check if a directory argument was provided
  // process.argv[0] = node/electron executable
  // process.argv[1] = script path (main.js)
  // process.argv[2+] = user arguments
  const args = process.argv.slice(2)
  if (args.length > 0 && fs.existsSync(args[0])) {
    const argPath = path.resolve(args[0])
    if (fs.statSync(argPath).isDirectory() && isRepository(argPath)) {
      console.log(`Launched with repository argument: ${argPath}`)
      return { configDir: path.join(argPath, '.nt'), repositoryPath: argPath }
    }
  }

  // Check if current working directory is a repository
  const cwd = process.cwd()
  if (isRepository(cwd)) {
    console.log(`Launched from repository: ${cwd}`)
    return { configDir: path.join(cwd, '.nt'), repositoryPath: cwd }
  }

  // Default: use NT_HOME or ~/.nt
  console.log('Launched in standard mode')
  return { configDir: homeDir(), repositoryPath: null }
}

export default class ConfigManager {
  // Static (~/.nt/editorconfig.jsonnet), Dynamic (~/.nt/editorconfig.json) or Collection (.nt/config)?
  //
  // * Static configuration refers to configuration specific to The NoteWriter Desktop application
  //   Ex: journaling templates, etc.
  // * Dynamic configuration is also specific to The NoteWriter Desktop application but is not expected
  //   to be edited manually. This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorStaticConfig!: EditorStaticConfig

  editorDynamicConfig!: EditorDynamicConfig

  repositoryConfigs: { [key: string]: RepositoryConfig } = {}

  private constructor() {
    // Private constructor to enforce use of create() factory method
  }

  // Async factory method for creating ConfigManager
  static async create(): Promise<ConfigManager> {
    // Determine launch context
    const { configDir, repositoryPath } = determineLaunchContext()
    activeConfigDirectory = configDir

    const staticConfig = await ConfigManager.#readStaticConfig(repositoryPath)
    const dynamicConfig = await ConfigManager.#readDynamicConfig()

    // Create instance manually to avoid calling constructor
    const instance = Object.create(ConfigManager.prototype)
    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await ConfigManager.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  static async #readStaticConfig(repositoryPath: string | null): Promise<EditorStaticConfig> {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.jsonnet')

    // If launched from a repository, check for .nt/editorconfig.jsonnet
    // If it doesn't exist, generate an in-memory config
    if (repositoryPath) {
      if (fs.existsSync(homeConfigPath)) {
        console.log(`Reading configuration from ${homeConfigPath}`)
        return await ConfigManager.#evaluateJsonnetConfig(homeConfigPath)
      } else {
        console.log(`No editorconfig.jsonnet found in repository, generating in-memory config`)
        return ConfigManager.#generateDefaultRepositoryConfig(repositoryPath)
      }
    }

    // Standard mode: read from NT_HOME or ~/.nt
    if (!fs.existsSync(homeConfigPath)) {
      throw new Error(`No configuration file found. Expected: ${homeConfigPath}`)
    }

    console.log(`Reading configuration from ${homeConfigPath}`)
    return await ConfigManager.#evaluateJsonnetConfig(homeConfigPath)
  }

  // Evaluate a Jsonnet configuration file
  static async #evaluateJsonnetConfig(configPath: string): Promise<EditorStaticConfig> {
    // Several solutions exist to evaluate Jsonnet files in Node.js:
    // * Use a WebAssembly to run the Jsonnet VM in the browser (no popular library found)
    // * Use a native Node.js addon (ex: https://github.com/hanazuki/node-jsonnet but many issues after every upgrade of cmake)
    // * Use the jsonnet binary directly (requires users to install jsonnet separately)
    // For simplicity, we use the latest solution for now.

    try {
      // Execute jsonnet binary from PATH
      const { stdout } = await execFileAsync('jsonnet', [configPath])
      const config = JSON.parse(stdout) as EditorStaticConfig
      return ConfigManager.#applyDefaultStaticConfig(config)
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(
          'jsonnet binary not found in PATH. Please install jsonnet: https://github.com/google/go-jsonnet'
        )
      }
      throw new Error(`Failed to evaluate Jsonnet file: ${error.message}`)
    }
  }

  // Generate a default configuration for a single repository
  static #generateDefaultRepositoryConfig(repositoryPath: string): EditorStaticConfig {
    const config: EditorStaticConfig = {
      repositories: [
        {
          name: 'Default',
          slug: 'default',
          path: repositoryPath,
          selected: true
        }
      ]
    }
    return ConfigManager.#applyDefaultStaticConfig(config)
  }

  static async #readDynamicConfig(): Promise<EditorDynamicConfig> {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json')
    if (!fs.existsSync(homeConfigPath)) {
      // Define default configuration
      return {
        desks: [],
        favorites: [],
        bookmarks: [],
        tags: []
      } as EditorDynamicConfig
    }

    const data = fs.readFileSync(homeConfigPath, 'utf8')
    console.log(`Reading dynamic configuration from ${homeConfigPath}...`)
    const config = JSON.parse(data) as EditorDynamicConfig
    console.log(data, config)
    return config
  }

  static async #readRepositoryConfig(
    repositoryRef: RepositoryRefConfig
  ): Promise<RepositoryConfig> {
    const repositoryPath = normalizePath(repositoryRef.path)
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json')
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`)
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8')
    const config = JSON.parse(data) as RepositoryConfig
    return config
  }

  // Traverse the static configuration to apply default values.
  static #applyDefaultStaticConfig(config: EditorStaticConfig): EditorStaticConfig {
    const selectedRepositorySlugs: string[] = []

    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i]
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true
        }
        if (repository.selected) {
          selectedRepositorySlugs.push(repository.slug)
        }
      }
    }

    // Define default daily quote
    const defaultDailyQuote: DailyQuoteConfig = {
      query: `@type:quote`, // any quote
      repositories: selectedRepositorySlugs // default repositories
    }
    if (!config.dailyQuote) {
      config.dailyQuote = defaultDailyQuote
    }

    // Use default selected repositories when none are specified
    if (config.zenMode) {
      for (let i = 0; i < config.zenMode.queries.length; i++) {
        const query = config.zenMode.queries[i]
        if (!query.repositories) {
          query.repositories = selectedRepositorySlugs
        }
      }
    }
    if (config.inspirations) {
      for (let i = 0; i < config.inspirations.length; i++) {
        const inspiration = config.inspirations[i]
        if (!inspiration.repositories) {
          inspiration.repositories = selectedRepositorySlugs
        }
      }
    }

    return config
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories.filter((repository) => repository.selected)
  }

  save(config: EditorDynamicConfig) {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json')
    console.log(`Saving ${homeConfigPath}...`)
    const content = JSON.stringify(config)
    console.log(content)
    fs.writeFile(homeConfigPath, content, (err) => {
      if (err) {
        console.error(err)
      }
    })
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug)
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects')
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`)
    }
    return objectsPath
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorStaticConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`)
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug]
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`)
    }
    return repositoryConfig
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(deckRef.repositorySlug)
    if (!repositoryConfig.decks) {
      throw new Error(`No decks found for repository ${deckRef.repositorySlug}`)
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck
      }
    }
    throw new Error(`No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`)
  }
}

import path from 'path'
import os from 'os'
import fs from 'fs'
import { execFile } from 'child_process'
import { promisify } from 'util'

import {
  EditorStaticConfig,
  EditorDynamicConfig,
  RepositoryRefConfig,
  DailyQuoteConfig,
  RepositoryConfig,
  DeckRef,
  DeckConfig
} from './Model'
import { normalizePath } from './util'

const execFileAsync = promisify(execFile)

// Detect if a directory is a NoteWriter repository
export function isRepository(dirPath: string): boolean {
  const ntDir = path.join(dirPath, '.nt')
  return fs.existsSync(ntDir) && fs.statSync(ntDir).isDirectory()
}

export default class ConfigManager {
  // Static (~/.nt/editorconfig.jsonnet), Dynamic (~/.nt/editorconfig.json) or Collection (.nt/config)?
  //
  // * Static configuration refers to configuration specific to The NoteWriter Desktop application
  //   Ex: journaling templates, etc.
  // * Dynamic configuration is also specific to The NoteWriter Desktop application but is not expected
  //   to be edited manually. This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorStaticConfig!: EditorStaticConfig

  editorDynamicConfig!: EditorDynamicConfig

  repositoryConfigs: { [key: string]: RepositoryConfig } = {}

  // Configuration directory path where editorconfig.jsonnet and editorconfig.json are stored
  configDir!: string

  private constructor() {
    // Private constructor to enforce use of createMono() or createMulti() factory methods
  }

  // Create ConfigManager for single repository mode
  // repositoryPath: absolute path to the repository directory
  static async createMono(repositoryPath: string): Promise<ConfigManager> {
    const configDir = path.join(repositoryPath, '.nt')
    const configPath = path.join(configDir, 'editorconfig.jsonnet')

    let staticConfig: EditorStaticConfig
    if (fs.existsSync(configPath)) {
      console.log(`Reading configuration from ${configPath}`)
      staticConfig = await ConfigManager.#evaluateJsonnetConfig(configPath)
    } else {
      console.log(`No editorconfig.jsonnet found in repository, generating in-memory config`)
      staticConfig = ConfigManager.#generateDefaultRepositoryConfig(repositoryPath)
    }

    const dynamicConfig = await ConfigManager.#readDynamicConfig(configDir)

    // Create instance
    const instance = Object.create(ConfigManager.prototype)
    instance.configDir = configDir
    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  // Create ConfigManager for multi repository mode
  // configPath: absolute path to the directory containing editorconfig.jsonnet (typically $NT_HOME)
  static async createMulti(configPath: string): Promise<ConfigManager> {
    const configFile = path.join(configPath, 'editorconfig.jsonnet')

    if (!fs.existsSync(configFile)) {
      throw new Error(`No configuration file found. Expected: ${configFile}`)
    }

    console.log(`Reading configuration from ${configFile}`)
    const staticConfig = await ConfigManager.#evaluateJsonnetConfig(configFile)
    const dynamicConfig = await ConfigManager.#readDynamicConfig(configPath)

    // Create instance
    const instance = Object.create(ConfigManager.prototype)
    instance.configDir = configPath
    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await instance.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  // Evaluate a Jsonnet configuration file
  static async #evaluateJsonnetConfig(configPath: string): Promise<EditorStaticConfig> {
    // Several solutions exist to evaluate Jsonnet files in Node.js:
    // * Use a WebAssembly to run the Jsonnet VM in the browser (no popular library found)
    // * Use a native Node.js addon (ex: https://github.com/hanazuki/node-jsonnet but many issues after every upgrade of cmake)
    // * Use the jsonnet binary directly (requires users to install jsonnet separately)
    // For simplicity, we use the latest solution for now.

    try {
      // Execute jsonnet binary from PATH
      const { stdout } = await execFileAsync('jsonnet', [configPath])
      const config = JSON.parse(stdout) as EditorStaticConfig
      return ConfigManager.#applyDefaultStaticConfig(config)
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(
          'jsonnet binary not found in PATH. Please install jsonnet: https://github.com/google/go-jsonnet'
        )
      }
      throw new Error(`Failed to evaluate Jsonnet file: ${error.message}`)
    }
  }

  // Generate a default configuration for a single repository
  static #generateDefaultRepositoryConfig(repositoryPath: string): EditorStaticConfig {
    const config: EditorStaticConfig = {
      repositories: [
        {
          name: 'Default',
          slug: 'default',
          path: repositoryPath,
          selected: true
        }
      ]
    }
    return ConfigManager.#applyDefaultStaticConfig(config)
  }

  static async #readDynamicConfig(configDir: string): Promise<EditorDynamicConfig> {
    const dynamicConfigPath = path.join(configDir, 'editorconfig.json')
    if (!fs.existsSync(dynamicConfigPath)) {
      // Define default configuration
      return {
        desks: [],
        favorites: [],
        bookmarks: [],
        tags: []
      } as EditorDynamicConfig
    }

    const data = fs.readFileSync(dynamicConfigPath, 'utf8')
    console.log(`Reading dynamic configuration from ${dynamicConfigPath}...`)
    const config = JSON.parse(data) as EditorDynamicConfig
    console.log(data, config)
    return config
  }

  async #readRepositoryConfig(repositoryRef: RepositoryRefConfig): Promise<RepositoryConfig> {
    const repositoryPath = normalizePath(repositoryRef.path)
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json')
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`)
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8')
    const config = JSON.parse(data) as RepositoryConfig
    return config
  }

  // Traverse the static configuration to apply default values.
  static #applyDefaultStaticConfig(config: EditorStaticConfig): EditorStaticConfig {
    const selectedRepositorySlugs: string[] = []

    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i]
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true
        }
        if (repository.selected) {
          selectedRepositorySlugs.push(repository.slug)
        }
      }
    }

    // Define default daily quote
    const defaultDailyQuote: DailyQuoteConfig = {
      query: `@type:quote`, // any quote
      repositories: selectedRepositorySlugs // default repositories
    }
    if (!config.dailyQuote) {
      config.dailyQuote = defaultDailyQuote
    }

    // Use default selected repositories when none are specified
    if (config.zenMode) {
      for (let i = 0; i < config.zenMode.queries.length; i++) {
        const query = config.zenMode.queries[i]
        if (!query.repositories) {
          query.repositories = selectedRepositorySlugs
        }
      }
    }
    if (config.inspirations) {
      for (let i = 0; i < config.inspirations.length; i++) {
        const inspiration = config.inspirations[i]
        if (!inspiration.repositories) {
          inspiration.repositories = selectedRepositorySlugs
        }
      }
    }

    return config
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories.filter((repository) => repository.selected)
  }

  save(config: EditorDynamicConfig) {
    const configPath = path.join(this.configDir, 'editorconfig.json')
    console.log(`Saving ${configPath}...`)
    const content = JSON.stringify(config)
    console.log(content)
    fs.writeFile(configPath, content, (err) => {
      if (err) {
        console.error(err)
      }
    })
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug)
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects')
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`)
    }
    return objectsPath
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorStaticConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`)
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug]
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`)
    }
    return repositoryConfig
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(deckRef.repositorySlug)
    if (!repositoryConfig.decks) {
      throw new Error(`No decks found for repository ${deckRef.repositorySlug}`)
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck
      }
    }
    throw new Error(`No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`)
  }
}

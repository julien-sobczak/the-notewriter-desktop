import path from 'path'
import os from 'os'
import fs from 'fs'
import { execFile } from 'child_process'
import { promisify } from 'util'

import {
  EditorStaticConfig,
  EditorDynamicConfig,
  RepositoryRefConfig,
  DailyQuoteConfig,
  RepositoryConfig,
  DeckRef,
  DeckConfig
} from './Model'
import { normalizePath } from './util'

const execFileAsync = promisify(execFile)

// Returns the home directory except if the environment variable $NT_HOME is set.
export function homeDir() {
  console.log(`NT_HOME is set to ${process.env.NT_HOME}`)
  if (process.env.NT_HOME) {
    return process.env.NT_HOME
  }
  return path.join(os.homedir(), '.nt')
}

export default class ConfigManager {
  // Static (~/.nt/editorconfig.jsonnet), Dynamic (~/.nt/editorconfig.json) or Collection (.nt/config)?
  //
  // * Static configuration refers to configuration specific to The NoteWriter Desktop application
  //   Ex: journaling templates, etc.
  // * Dynamic configuration is also specific to The NoteWriter Desktop application but is not expected
  //   to be edited manually. This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorStaticConfig!: EditorStaticConfig

  editorDynamicConfig!: EditorDynamicConfig

  repositoryConfigs: { [key: string]: RepositoryConfig } = {}

  private constructor() {
    // Private constructor to enforce use of create() factory method
  }

  // Async factory method for creating ConfigManager
  static async create(): Promise<ConfigManager> {
    const staticConfig = await ConfigManager.#readStaticConfig()
    const dynamicConfig = await ConfigManager.#readDynamicConfig()

    // Create instance manually to avoid calling constructor
    const instance = Object.create(ConfigManager.prototype)
    instance.editorStaticConfig = staticConfig
    instance.editorDynamicConfig = dynamicConfig
    instance.repositoryConfigs = {}

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        await ConfigManager.#readRepositoryConfig(repositoryConfig)
    }

    return instance
  }

  static async #readStaticConfig(): Promise<EditorStaticConfig> {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.jsonnet')

    if (!fs.existsSync(homeConfigPath)) {
      throw new Error(`No configuration file found. Expected: ${homeConfigPath}`)
    }

    console.log(`Reading configuration from ${homeConfigPath}`)

    // Several solutions exist to evaluate Jsonnet files in Node.js:
    // * Use a WebAssembly to run the Jsonnet VM in the browser (no popular library found)
    // * Use a native Node.js addon (ex: https://github.com/hanazuki/node-jsonnet but many issues after every upgrade of cmake)
    // * Use the jsonnet binary directly (requires users to install jsonnet separately)
    // For simplicity, we use the latest solution for now.

    try {
      // Execute jsonnet binary from PATH
      const { stdout } = await execFileAsync('jsonnet', [homeConfigPath])
      const config = JSON.parse(stdout) as EditorStaticConfig
      return ConfigManager.#applyDefaultStaticConfig(config)
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(
          'jsonnet binary not found in PATH. Please install jsonnet: https://github.com/google/go-jsonnet'
        )
      }
      throw new Error(`Failed to evaluate Jsonnet file: ${error.message}`)
    }
  }

  static async #readDynamicConfig(): Promise<EditorDynamicConfig> {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json')
    if (!fs.existsSync(homeConfigPath)) {
      // Define default configuration
      return {
        desks: [],
        favorites: [],
        bookmarks: [],
        tags: []
      } as EditorDynamicConfig
    }

    const data = fs.readFileSync(homeConfigPath, 'utf8')
    console.log(`Reading dynamic configuration from ${homeConfigPath}...`)
    const config = JSON.parse(data) as EditorDynamicConfig
    console.log(data, config)
    return config
  }

  static async #readRepositoryConfig(
    repositoryRef: RepositoryRefConfig
  ): Promise<RepositoryConfig> {
    const repositoryPath = normalizePath(repositoryRef.path)
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json')
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`)
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8')
    const config = JSON.parse(data) as RepositoryConfig
    return config
  }

  // Traverse the static configuration to apply default values.
  static #applyDefaultStaticConfig(config: EditorStaticConfig): EditorStaticConfig {
    const selectedRepositorySlugs: string[] = []

    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i]
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true
        }
        if (repository.selected) {
          selectedRepositorySlugs.push(repository.slug)
        }
      }
    }

    // Define default daily quote
    const defaultDailyQuote: DailyQuoteConfig = {
      query: `@type:quote`, // any quote
      repositories: selectedRepositorySlugs // default repositories
    }
    if (!config.dailyQuote) {
      config.dailyQuote = defaultDailyQuote
    }

    // Use default selected repositories when none are specified
    if (config.zenMode) {
      for (let i = 0; i < config.zenMode.queries.length; i++) {
        const query = config.zenMode.queries[i]
        if (!query.repositories) {
          query.repositories = selectedRepositorySlugs
        }
      }
    }
    if (config.inspirations) {
      for (let i = 0; i < config.inspirations.length; i++) {
        const inspiration = config.inspirations[i]
        if (!inspiration.repositories) {
          inspiration.repositories = selectedRepositorySlugs
        }
      }
    }

    return config
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories.filter((repository) => repository.selected)
  }

  save(config: EditorDynamicConfig) {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json')
    console.log(`Saving ${homeConfigPath}...`)
    const content = JSON.stringify(config)
    console.log(content)
    fs.writeFile(homeConfigPath, content, (err) => {
      if (err) {
        console.error(err)
      }
    })
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug)
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects')
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`)
    }
    return objectsPath
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorStaticConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`)
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug]
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`)
    }
    return repositoryConfig
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(deckRef.repositorySlug)
    if (!repositoryConfig.decks) {
      throw new Error(`No decks found for repository ${deckRef.repositorySlug}`)
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck
      }
    }
    throw new Error(`No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`)
  }
}

import path from 'path';
import os from 'os';
import fs from 'fs';
import yaml from 'js-yaml';
import { v4 as uuidv4 } from 'uuid'; // uuidv4()
import { Jsonnet } from '@hanazuki/node-jsonnet';

import {
  EditorStaticConfig,
  EditorDynamicConfig,
  RepositoryRefConfig,
  DailyQuoteConfig,
  RepositoryConfig,
  DeckRef,
  Review,
  PackFile,
  Study,
  DeckConfig,
} from '../shared/Model';
import { normalizePath } from './util';

// Returns the home directory except if the environment variable $NT_HOME is set.
export function homeDir() {
  console.log(`NT_HOME is set to ${process.env.NT_HOME}`);
  if (process.env.NT_HOME) {
    return process.env.NT_HOME;
  }
  return path.join(os.homedir(), '.nt');
}

export default class ConfigManager {
  // Static (~/.nt/editorconfig.jsonnet), Dynamic (~/.nt/editorconfig.json) or Collection (.nt/config)?
  //
  // * Static configuration refers to configuration specific to The NoteWriter Desktop application
  //   Ex: journaling templates, etc.
  // * Dynamic configuration is also specific to The NoteWriter Desktop application but is not expected
  //   to be edited manually. This file is generated by the application itself.
  //   Ex: Workspace templates, processed reminders, etc.
  // * Collection configuration is the main configuration file when using the command 'nt'.
  //   All configurations that must be shared between applications (CLI, Nomad, Desktop) must be
  //   present in this file as these configurations are saved in remote too.

  editorStaticConfig: EditorStaticConfig;

  editorDynamicConfig: EditorDynamicConfig;

  repositoryConfigs: { [key: string]: RepositoryConfig } = {};

  constructor() {
    throw new Error(
      'ConfigManager constructor is deprecated. Use ConfigManager.create() instead.',
    );
  }

  // Async factory method for creating ConfigManager with Jsonnet support
  static async create(): Promise<ConfigManager> {
    const staticConfig = await ConfigManager.#readStaticConfig();
    const dynamicConfig = ConfigManager.#readDynamicConfig();

    // Create instance manually to avoid calling constructor
    const instance = Object.create(ConfigManager.prototype);
    instance.editorStaticConfig = staticConfig;
    instance.editorDynamicConfig = dynamicConfig;
    instance.repositoryConfigs = {};

    for (const repositoryConfig of instance.editorStaticConfig.repositories) {
      instance.repositoryConfigs[repositoryConfig.slug] =
        ConfigManager.#readRepositoryConfig(repositoryConfig);
    }

    return instance;
  }

  static async #readStaticConfig(): Promise<EditorStaticConfig> {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.jsonnet');

    if (!fs.existsSync(homeConfigPath)) {
      throw new Error(
        `No configuration file found. Expected: ${homeConfigPath}`,
      );
    }

    console.log(`Reading configuration from ${homeConfigPath}`);

    const jsonnet = new Jsonnet();
    const jsonStr = await jsonnet.evaluateFile(homeConfigPath);
    const config = JSON.parse(jsonStr) as EditorStaticConfig;
    return ConfigManager.#applyDefaultStaticConfig(config);
  }

  static #readDynamicConfig() {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json');
    if (!fs.existsSync(homeConfigPath)) {
      // Define default configuration
      return {
        desks: [],
        favorites: [],
        bookmarks: [],
      } as EditorDynamicConfig;
    }

    const data = fs.readFileSync(homeConfigPath, 'utf8');
    return JSON.parse(data) as EditorDynamicConfig;
  }

  static #readRepositoryConfig(
    repositoryRef: RepositoryRefConfig,
  ): RepositoryConfig {
    const repositoryPath = normalizePath(repositoryRef.path);
    const repositoryConfigPath = path.join(repositoryPath, '.nt/.config.json');
    if (!fs.existsSync(repositoryConfigPath)) {
      throw new Error(`Missing configuration ${repositoryConfigPath}`);
    }
    const data = fs.readFileSync(repositoryConfigPath, 'utf8');
    const config = JSON.parse(data) as RepositoryConfig;
    return config;
  }

  // Traverse the static configuration to apply default values.
  static #applyDefaultStaticConfig(
    config: EditorStaticConfig,
  ): EditorStaticConfig {
    const selectedRepositorySlugs: string[] = [];

    // Select repositories by default
    if (config.repositories) {
      for (let i = 0; i < config.repositories.length; i++) {
        const repository = config.repositories[i];
        if (repository.selected === undefined) {
          // Repositories are selected by default
          repository.selected = true;
        }
        if (repository.selected) {
          selectedRepositorySlugs.push(repository.slug);
        }
      }
    }

    // Define default daily quote
    const defaultDailyQuote: DailyQuoteConfig = {
      query: `@type:quote`, // any quote
      repositories: selectedRepositorySlugs, // default repositories
    };
    if (!config.dailyQuote) {
      config.dailyQuote = defaultDailyQuote;
    }

    // Use default selected repositories when none are specified
    if (config.zenMode) {
      for (let i = 0; i < config.zenMode.queries.length; i++) {
        const query = config.zenMode.queries[i];
        if (!query.repositories) {
          query.repositories = selectedRepositorySlugs;
        }
      }
    }
    if (config.inspirations) {
      for (let i = 0; i < config.inspirations.length; i++) {
        const inspiration = config.inspirations[i];
        if (!inspiration.repositories) {
          inspiration.repositories = selectedRepositorySlugs;
        }
      }
    }

    return config;
  }

  // Returns all declared repositories.
  repositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories;
  }

  // Returns only repositories selected by default.
  selectedRepositories(): RepositoryRefConfig[] {
    return this.editorStaticConfig.repositories.filter(
      (repository) => repository.selected,
    );
  }

  // eslint-disable-next-line class-methods-use-this
  save(config: EditorDynamicConfig) {
    const homeConfigPath = path.join(homeDir(), 'editorconfig.json');
    console.log(`Saving ${homeConfigPath}...`);
    fs.writeFile(homeConfigPath, JSON.stringify(config), (err) => {
      if (err) {
        console.error(err);
      }
    });
  }

  /*
   * Study Management
   */

  // Review objects are grouped into Study objects that are committed,
  // just like when you use the command 'nt commit'.
  // To not create too much commits, the user must triggers the action explicitly.
  // During that time, we still need to save reviews locally.
  // We use the directory ~/.nt/study where a single file is present for every deck
  // (the file is only created after the first review and deleted after a commit).
  // These files are YAML files containing a list of Study objects.
  // These files are not packfiles (to make easy to read them without unpacking them first).

  // eslint-disable-next-line class-methods-use-this
  appendReviewToStudy(deckRef: DeckRef, review: Review) {
    // FIXME still useful?
    const studyFilePath = studyPath(deckRef);

    const now = new Date();

    // Try to load the existing file
    let studies: Study[] = [];
    if (fs.existsSync(studyFilePath)) {
      const data = fs.readFileSync(studyFilePath, 'utf8');
      studies = yaml.load(data) as Study[];
    }
    // Try to find a study in progress
    let studyToComplete: Study | undefined;
    // Studies are appended sequentially
    for (let i = studies.length - 1; i >= 0; i--) {
      const study = studies[i];
      const studyStartedAt = Date.parse(study.startedAt);
      const elapsedTimeInHours = Math.ceil(
        ((studyStartedAt - now.getDate()) / 1000) * 60 * 60,
      );
      if (elapsedTimeInHours <= 1) {
        // Started in the last hour?
        studyToComplete = study;
        break;
      }
    }
    if (!studyToComplete) {
      studyToComplete = {
        oid: uuidv4(),
        startedAt: now.toISOString(),
        endedAt: now.toISOString(),
        reviews: [],
      };
      studies.push(studyToComplete);
    }

    // Append the new review
    studyToComplete.reviews.push(review);

    // Write back the study file
    const studiesRaw = yaml.dump(studies, {});
    fs.writeFileSync(studyFilePath, studiesRaw);
    // OPTIMIZE Save the file after every X reviews instead
  }

  // eslint-disable-next-line class-methods-use-this
  commitDeck(deckRef: DeckRef) {
    const studyFilePath = studyPath(deckRef);

    // Try to load the existing commit
    if (!fs.existsSync(studyFilePath)) {
      // Nothing to commit
      return;
    }

    const data = fs.readFileSync(studyFilePath, 'utf8');
    const studies = yaml.load(data) as Study[];
    if (studies.length === 0) {
      // Nothing to commit
      return;
    }

    const now = new Date();

    // Create a new pack file
    const packFile: PackFile = {
      oid: uuidv4(),
      file_mtime: '',
      file_size: 0,
      ctime: now.toISOString(),
      objects: [],
      blobs: [],
    };
    for (const study of studies) {
      packFile.objects.push({
        oid: study.oid,
        kind: 'study',
        description: 'Study',
        ctime: now.toISOString(),
        data: `TODO`, // TODO now
      });
      /*
      Each object is self-containing through the `data` attribute and compressed using zlib and encoded in Base 64. You can easily retrieve the uncompressed content:

      ```shell
      # On MacOS
      $ brew install qpdf
      $ echo "<value>" | base64 -d | zlib-flate -uncompress
      oid: 6ee8a962
      file_oid: d19a2bba
      kind: note
      relative_path: hello.md
      wikilink: 'hello#Note: Hello'
      content_raw: Coucou
      content_hash: b70f7d0e2acef2e0fa1c6f117e3c11e0d7082232
      ...
      ```
    */
    }

    // Create the pack file
    const objectsPath = this.mustGetObjectsPath(deckRef.repositorySlug);

    const packFilePath = path.join(
      objectsPath,
      packFile.oid.substring(0, 2),
      packFile.oid,
    );
    const packFileRaw = yaml.dump(packFile);
    fs.writeFileSync(packFilePath, packFileRaw);

    // Clear local studies as everything is sync
    fs.rmSync(studyFilePath);
  }

  // Returns the path .nt/objects for a given repository
  mustGetObjectsPath(repositorySlug: string): string {
    const repositoryConfig = this.mustGetRepositoryRefConfig(repositorySlug);
    const objectsPath = path.join(repositoryConfig.path, '.nt/objects');
    if (!fs.existsSync(objectsPath)) {
      throw new Error(`${objectsPath} does not exist`);
    }
    return objectsPath;
  }

  // Returns the config ref for the given repository.
  mustGetRepositoryRefConfig(repositorySlug: string): RepositoryRefConfig {
    for (const repositoryConfig of this.editorStaticConfig.repositories) {
      if (repositoryConfig.slug === repositorySlug) {
        return repositoryConfig;
      }
    }
    throw new Error(`No repository with slug ${repositorySlug}`);
  }

  // Returns the config for the given repository.
  mustGetRepositoryConfig(repositorySlug: string): RepositoryConfig {
    // Iterate over this.repositoryConfigs
    const repositoryConfig = this.repositoryConfigs[repositorySlug];
    if (!repositoryConfig) {
      throw new Error(`No repository config for slug ${repositorySlug}`);
    }
    return repositoryConfig;
  }

  // Returns the deck config.
  mustGetDeckConfig(deckRef: DeckRef): DeckConfig {
    const repositoryConfig = this.mustGetRepositoryConfig(
      deckRef.repositorySlug,
    );
    if (!repositoryConfig.decks) {
      throw new Error(
        `No decks found for repository ${deckRef.repositorySlug}`,
      );
    }
    for (const deck of repositoryConfig.decks) {
      if (deck.name === deckRef.name) {
        return deck;
      }
    }
    throw new Error(
      `No deck with name ${deckRef.name} in repository ${deckRef.repositorySlug}`,
    );
  }
}

/* Helpers */

// Returns the file path where uncommitted studies are persisted locally on-disk.
export function studyPath(deckRef: DeckRef): string {
  // FIXME still usefu;?
  const dirPath = path.join(homeDir(), 'studies');
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath);
  }
  const filePath = path.join(
    dirPath,
    `${deckRef.repositorySlug}-${deckRef.name}.yml`,
  );
  return filePath;
}
